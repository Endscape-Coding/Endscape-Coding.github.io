<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endscape Searcher</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Arial', sans-serif;
            color: #fff;
        }
        canvas { 
            display: block; 
        }
        .search-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90%;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .search-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 22px;
            font-weight: 300;
        }
        .search-box {
            display: flex;
            margin-bottom: 15px;
        }
        .search-input {
            flex: 1;
            padding: 10px 15px;
            font-size: 14px;
            border: none;
            border-radius: 6px 0 0 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            outline: none;
        }
        .search-button {
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 0 6px 6px 0;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        .engine-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
        }
        .engine-btn {
            padding: 5px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-size: 12px;
        }
        .engine-btn.active {
            background: rgba(255, 255, 255, 0.2);
        }
        .hint {
            text-align: center;
            margin-top: 12px;
            font-size: 10px;
            opacity: 0.5;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="loading" id="loadingScreen">
        <div>Loading...</div>
    </div>

    <div class="search-container">
        <h1 class="search-title">EN Search</h1>
        <div class="search-box">
            <input type="text" class="search-input" placeholder="Search the web..." id="searchInput">
            <button class="search-button" id="searchButton">Search</button>
        </div>
        <div class="engine-selector">
            <button class="engine-btn" data-engine="google">Google</button>
            <button class="engine-btn" data-engine="yandex">Yandex</button>
            <button class="engine-btn" data-engine="duckduckgo">DuckDuckGo</button>
        </div>
        <div class="hint">Select search engine (saved automatically)</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { AfterimagePass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/AfterimagePass.js';
        import { ShaderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/shaders/RGBShiftShader.js';

        // Сначала создаем базовые элементы сцены
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 120;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Сразу добавляем ambient light чтобы сцена не была полностью черной
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        // Создаем несколько базовых частиц сразу
        const tempColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
        let particles = [];
        
        function createInitialParticles() {
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 1 + 0.3, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: tempColors[Math.floor(Math.random() * tempColors.length)],
                    emissive: 0x222222,
                    emissiveIntensity: 0.2
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );
                scene.add(sphere);
                particles.push({
                    mesh: sphere,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    )
                });
            }
        }
        
        createInitialParticles();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.025;
        controls.enableZoom = true;
        controls.minDistance = 10;
        controls.maxDistance = 400;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const afterimagePass = new AfterimagePass(0.89);
        composer.addPass(afterimagePass);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 3, 0.4, 0.5);
        composer.addPass(bloomPass);

        const mouse = new THREE.Vector2(0.5, 0.5);
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX / window.innerWidth;
            mouse.y = 1.0 - e.clientY / window.innerHeight;
        });
        
        const fluidShader = {
            uniforms: {
                tDiffuse: { value: null },
                mouse: { value: new THREE.Vector2(0.5, 0.5) },
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 mouse;
                uniform float time;
                uniform vec2 resolution;
                varying vec2 vUv;
                void main() {
                    vec2 uv = vUv;

                    // Distance from mouse
                    vec2 mouseUV = mouse;
                    vec2 delta = uv - mouseUV;
                    float dist = length(delta);

                    // Fluid distortion
                    float strength = 0.3;
                    float falloff = smoothstep(0.02, 0.2, dist);
                    vec2 offset = normalize(delta) * strength * exp(-dist * 20.0) * falloff;

                    // Time-based ripple
                    float ripple = -sin(dist * 10.0 - time * 3.0) * 0.05;
                    offset += delta * ripple;

                    vec4 color = texture2D(tDiffuse, uv + offset);
                    gl_FragColor = color;
                }
            `
        };

        const RadialVignetteShader = {
            uniforms: {
                tDiffuse: { value: null },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                vignetteIntensity: { value: 0.3 },
                vignetteSmoothness: { value: 0.5 },
                blurStrength: { value: 0.15 },
                blurSamples: { value: 64 }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 resolution;
                uniform float vignetteIntensity;
                uniform float vignetteSmoothness;
                uniform float blurStrength;
                uniform int blurSamples;
                varying vec2 vUv;
                void main() {
                    vec2 uv = vUv;
                    vec2 center = vec2(0.5, 0.5);
                    vec2 delta = uv - center;
                    float dist = length(delta);
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    for (int i = 0; i < 256; i++) {
                        if(i >= blurSamples) break;
                        float t = float(i) / float(blurSamples - 1);
                        vec2 sampleUv = center + delta * (1.0 + t * blurStrength);
                        color += texture2D(tDiffuse, sampleUv);
                        total += 1.0;
                    }
                    color /= total;
                    float vignette = smoothstep(0.1, vignetteSmoothness, dist);
                    color.rgb *= mix(1.0, 1.0 - vignetteIntensity, vignette);
                    gl_FragColor = color;
                }
            `
        };

        const vignettePass = new ShaderPass(RadialVignetteShader);
        composer.addPass(vignettePass);

        const rgbShiftPass = new ShaderPass(RGBShiftShader);
        rgbShiftPass.uniforms['amount'].value = 0.0015;
        composer.addPass(rgbShiftPass);

        const dotShader = {
            uniforms: {
                tDiffuse: { value: null },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uScale: { value: 10.0 }
            },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
            fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform vec2 uResolution;
            uniform float uScale;
            varying vec2 vUv;

            void main() {
                vec2 uv = gl_FragCoord.xy / uScale;
                vec2 grid = fract(uv);
                float dist = length(grid - 0.05);
                float dot = smoothstep(0.05, 0.2, dist);

                vec4 sceneColor = texture2D(tDiffuse, vUv);
                vec3 finalColor = mix(sceneColor.rgb, vec3(0.0), dot * 0.3);

                gl_FragColor = vec4(finalColor, sceneColor.a);
            }
        `
        };
        const dotPass = new ShaderPass(dotShader);
        composer.addPass(dotPass);
        const fluidPass = new ShaderPass(fluidShader);
        composer.addPass(fluidPass);

        let colors = [];
        const particleSettings = { scale: 1, damping: 0.98 };
        const waveSettings = { amplitude: 2, frequency: 0.5 };
        const fluidSettings = { fluidEnabled: true };

        // Search engine functionality
        let currentEngine = localStorage.getItem('searchEngine') || 'google';
        
        // Update active button
        document.querySelectorAll('.engine-btn').forEach(btn => {
            if (btn.dataset.engine === currentEngine) {
                btn.classList.add('active');
            }
            
            btn.addEventListener('click', () => {
                document.querySelectorAll('.engine-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentEngine = btn.dataset.engine;
                localStorage.setItem('searchEngine', currentEngine);
            });
        });
        
        document.getElementById('searchButton').addEventListener('click', performSearch);
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') performSearch();
        });
        
        function performSearch() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            
            let searchUrl;
            switch(currentEngine) {
                case 'google':
                    searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
                    break;
                case 'yandex':
                    searchUrl = `https://yandex.com/search/?text=${encodeURIComponent(query)}`;
                    break;
                case 'duckduckgo':
                    searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
                    break;
            }
            
            window.open(searchUrl, '_blank');
        }

        function generateParticles(count = 1200) {
            // Удаляем временные частицы
            particles.forEach(p => scene.remove(p.mesh));
            particles.length = 0;

            const scale = particleSettings.scale;

            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry((Math.random() * 2 + 0.5) * scale, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: colors[Math.floor(Math.random() * colors.length)],
                    emissiveIntensity: 0.5
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random();
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                const direction = new THREE.Vector3(x, y, z).normalize().multiplyScalar(2);
                
                particles.push({
                    mesh: sphere,
                    velocity: direction
                });
                scene.add(sphere);
            }
            
            // Скрываем экран загрузки после создания частиц
            document.getElementById('loadingScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 500);
        }

        async function fetchRandomPalette() {
            try {
                const proxy = 'https://cors-anywhere.herokuapp.com/';
                const url = 'https://www.thecolorapi.com/scheme?mode=random&count=5';
                const response = await fetch(proxy + url);
                if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
                const data = await response.json();
                colors = data.colors.map(c => parseInt(c.hex.value.replace('#', '0x')));
                generateParticles();
            } catch (error) {
                console.error('Erreur lors de la récupération de la palette:', error);
                colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
                generateParticles();
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            controls.update();
            
            particles.forEach((p, i) => {
                p.mesh.position.add(p.velocity);
                p.velocity.multiplyScalar(particleSettings.damping);
                const t = time * 0.001 + i * 0.1;
                const amplitude = waveSettings.amplitude;
                const frequency = waveSettings.frequency;
                p.mesh.position.y += Math.sin(t * frequency) * amplitude * 0.1;
                p.mesh.position.x += Math.cos(t * frequency) * amplitude * 0.1;
                p.mesh.position.z += Math.sin(t * frequency) * amplitude * 0.1;
            });
            
            fluidPass.enabled = fluidSettings.fluidEnabled;
            fluidPass.uniforms.mouse.value.copy(mouse);
            fluidPass.uniforms.time.value = performance.now() * 0.001;

            composer.render();
        }
        
        // Запускаем анимацию сразу
        animate(0);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            dotPass.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });

        // Загружаем палитру после инициализации сцены
        fetchRandomPalette();
    </script>
</body>
</html>
